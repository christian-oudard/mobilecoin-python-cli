#!/usr/bin/env python3

import argparse
import http
import json
import os
import subprocess
from pathlib import Path

import requests

NETWORK = 'testnet'
assert NETWORK in ['testnet', 'mainnet']
DEFAULT_URL = 'http://127.0.0.1:9090/wallet'
MC_DATA = Path.home() / '.mobilecoin' / NETWORK
LOG_LOCATION = MC_DATA / 'wallet_server_log.txt'


class Client:

    def __init__(self, url=DEFAULT_URL, verbose=False):
        self.url = url
        self.verbose = verbose

    def _req(self, request_data):
        request_data.update({
            "jsonrpc": "2.0",
            "api_version": "2",
            "id": 1
        })

        if self.verbose:
            print('POST', self.url)
            print(json.dumps(request_data, indent=4))
            print()

        try:
            r = requests.post(self.url, json=request_data)
        except requests.ConnectionError:
            # print(f'Could not connect to server at {self.url}. Try running ./mobilecoin start')
            raise

        try:
            response_data = r.json()
        except ValueError:
            print('API Error:', r.text)
            exit(1)

        if self.verbose:
            print(r.status_code, http.client.responses[r.status_code])
            print(json.dumps(response_data, indent=4))
            print()

        return response_data

    def start(self, offline=False, bg=False):
        if NETWORK == 'testnet':
            wallet_server_command = ['./full-service-testnet']
        elif NETWORK == 'mainnet':
            wallet_server_command = ['./full-service-mainnet']

        wallet_server_command += [
            '--wallet-db', str(MC_DATA / 'wallet-db/encrypted-wallet.db'),
            '--ledger-db', str(MC_DATA / 'ledger-db'),
        ]
        if offline:
            wallet_server_command += [
                '--offline',
            ]
        else:
            if NETWORK == 'testnet':
                wallet_server_command += [
                    '--peer mc://node1.test.mobilecoin.com/',
                    '--peer mc://node2.test.mobilecoin.com/',
                    '--tx-source-url https://s3-us-west-1.amazonaws.com/mobilecoin.chain/node1.test.mobilecoin.com/',
                    '--tx-source-url https://s3-us-west-1.amazonaws.com/mobilecoin.chain/node2.test.mobilecoin.com/',
                ]
            elif NETWORK == 'mainnet':
                wallet_server_command += [
                    '--peer', 'mc://node1.prod.mobilecoinww.com/',
                    '--peer', 'mc://node2.prod.mobilecoinww.com/',
                    '--tx-source-url', 'https://ledger.mobilecoinww.com/node1.prod.mobilecoinww.com/',
                    '--tx-source-url', 'https://ledger.mobilecoinww.com/node2.prod.mobilecoinww.com/',
                ]
        if bg:
            wallet_server_command += [
                '>', str(LOG_LOCATION), '2>&1'
            ]

        if NETWORK == 'testnet':
            print('Starting TestNet wallet server...')
        elif NETWORK == 'mainnet':
            print('Starting MobileCoin wallet server...')

        if self.verbose:
            print(' '.join(wallet_server_command))

        MC_DATA.mkdir(parents=True, exist_ok=True)
        (MC_DATA / 'ledger-db').mkdir(exist_ok=True)
        (MC_DATA / 'wallet-db').mkdir(exist_ok=True)

        os.environ['RUST_LOG'] = 'info'
        os.environ['mc_ledger_sync'] = 'info'
        if bg:
            subprocess.Popen(' '.join(wallet_server_command), shell=True)
            print('Started, view log at {}.'.format(LOG_LOCATION))
            print('Stop server with "mobilecoin stop".')
        else:
            subprocess.run(' '.join(wallet_server_command), shell=True)

    def stop(self):
        if self.verbose:
            print('Stopping MobileCoin wallet server...')
        if NETWORK == 'testnet':
            subprocess.Popen(['killall', '-v', 'full-service-testnet'])
        elif NETWORK == 'mainnet':
            subprocess.Popen(['killall', '-v', 'full-service'])

    def list(self):
        return self._req({"method": "get_all_accounts"})

    def balance(self, account_id):
        return self._req({
            "method": "get_balance_for_account",
            "params": {
                "account_id": account_id,
            }
        })

    def create_account(self, name, block):
        params = {"name": name}
        if block is not None:
            params["first_block_index"] = str(int(block))
        return self._req({
            "method": "create_account",
            "params": params,
        })

    def import_account(self, name, entropy, block=None):
        params = {
            "entropy": entropy,
            "name": name
        }
        if block is not None:
            params["first_block_index"] = str(int(block))

        return self._req({
            "method": "import_account",
            "params": params,
        })

    def delete(self, account_id):
        return self._req({
            "method": "delete_account",
            "params": {
                "account_id": account_id,
            }
        })

    def transactions(self, account_id):
        return self._req({
            "method": "get_all_txos_by_account",
            "params": {
                "account_id": account_id
            }
        })

    def send(self, from_account_id, to_address, amount):
        amount = str(mob2pmob(amount))
        self._req({
            "method": "send_transaction",
            "params": {
                "account_id": from_account_id,
                "recipient_public_address": to_address,
                "value": amount,
            }
        })


# User Interface.

def load_account(client, prefix):
    data = client.list()
    account_ids = data['result']['account_ids']
    matching_ids = [
        a_id for a_id in account_ids
        if a_id.startswith(prefix)
    ]
    if len(matching_ids) == 0:
        print('Could not find account starting with', prefix)
        exit(1)
    elif len(matching_ids) == 1:
        account_id = matching_ids[0]
        return data['result']['account_map'][account_id]
    else:
        print('Multiple matching matching ids: {}'.format(', '.join(matching_ids)))
        exit(1)


def pmob2mob(x):
    return int(x) / 1e12


def mob2pmob(x):
    return int(float(x) * 1e12)


def main():
    parser = argparse.ArgumentParser(
        prog='mobilecoin',
        description='MobileCoin command-line wallet.',
    )
    parser.add_argument('-v', '--verbose', action='store_true', help='Show more information.')

    subparsers = parser.add_subparsers(dest='command', help='Commands')

    start_args = subparsers.add_parser('start', help='Start the local MobileCoin wallet server.')
    start_args.add_argument('--offline', action='store_true', help='Start in offline mode.')
    start_args.add_argument('--bg', action='store_true',
                            help='Start server in the background, stop with "mobilecoin stop".')

    subparsers.add_parser('stop', help='Stop the local MobileCoin wallet server.')

    subparsers.add_parser('list', help='List accounts.')

    balance_args = subparsers.add_parser('balance', help='Show account balance')
    balance_args.add_argument('account_id', help='Account ID code.')

    create_args = subparsers.add_parser('create', help='Create a new account.')
    create_args.add_argument('name', help='Account name.')
    create_args.add_argument('-b', '--block', type=int,
                             help='Block index at which to start the account. No transactions before this block will be loaded.')

    import_args = subparsers.add_parser('import', help='Import an account.')
    import_args.add_argument('-b', '--block', type=int,
                             help='Block index at which to start the account. No transactions before this block will be loaded.')
    import_args.add_argument('name', help='Account name.')
    import_args.add_argument('entropy', help='Secret root entropy.')

    delete_args = subparsers.add_parser('delete', help='Delete an account from local storage.')
    delete_args.add_argument('account_id', help='Account ID code.')

    transactions_args = subparsers.add_parser('transactions', help='List account transactions.')
    transactions_args.add_argument('account_id', help='Account ID code.', nargs='?')

    send_args = subparsers.add_parser('send', help='Send a transaction.')
    send_args.add_argument('amount', help='Amount of MOB to send.', type=float)
    send_args.add_argument('from_account_id', help='Account ID to send from.')
    send_args.add_argument('to_address', help='Address to send to.')

    args = parser.parse_args()
    args = vars(args)
    command = args.pop('command')
    if command is None:
        parser.print_help()
        exit(1)

    client = Client(verbose=args.pop('verbose'))

    if command == 'list':
        data = client.list(**args)
        accounts = data['result']['account_map']
        if len(accounts) == 0:
            print('No accounts.')
            return

        for account_id, account in accounts.items():
            print()
            print(account['name'])
            print('  id', account_id)
            print('  address', account['main_address'])
        print()
        return

    elif command == 'balance':
        account_id = args.pop('account_id')
        account = load_account(client, account_id)
        data = client.balance(account['account_id'])
        balance = data['result']['balance']
        if balance['is_synced']:
            print('{} MOB (synced)'.format(pmob2mob(balance['unspent_pmob'])))
        else:
            print('still syncing, {}/{} blocks scanned'.format(
                balance['account_block_count'], balance['network_block_count']))
        return

    elif command == 'create':
        data = client.create_account(**args)
        account_data = data['result']
        account_id = account_data['account']['account_id']
        filename = f'mobilecoin_secret_{account_id}.json'
        with open(filename, 'w') as f:
            json.dump(data['result'], f, indent=4)
        print('Created a new account, "{}".'.format(args['name']))
        print(f'Wrote secret credentials to {filename}')
        return

    elif command == 'import':
        client.import_account(**args)
        return

    elif command == 'delete':
        account_id = args.pop('account_id')
        account = load_account(client, account_id)

        confirmation = input('\n'.join([
            'This will delete all stored information for the account {},'.format(account['name']),
            'account id {}'.format(account['account_id']),
            'You will lose access to the funds in this account unless you',
            'restore it from the root entropy. Continue? (Y/n) '
        ]))
        if confirmation.lower() not in ['y', 'yes']:
            print('Cancelled.')
            return
        else:
            client.delete(account['account_id'])
            print('Deleted.')
            return

    else:  # No special handling.
        command_method = getattr(client, command)
        command_method(**args)
        return


if __name__ == '__main__':
    main()
